---
import Layout from "../layouts/Layout.astro";
import "../styles/main.css";
---

<Layout>
  <div class="landing">
    <div id="bird-container"></div>
    <div class="landing-content">
      <h1 class="landing-title">Hyugin</h1>
      <p class="landing-subtitle">
        Personal philosophy and thoughts on engineering
      </p>
      <div class="landing-links">
        <a href="https://compile.substack.com/" class="landing-link">Journal</a>
        <a href="https://github.com/hyugin" class="landing-link">GitHub</a>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Bird SVG animation
  // Color map: illustration colors by path index (after background removal)
  // Derived from the geometric raven illustration's color regions
  const BLACK = "#000000";
  const CHARCOAL = "#1c2728"; // very dark teal
  const TEAL_D = "#2c3c3d"; // dark teal
  const TEAL_M = "#435354"; // muted teal/slate
  const GRAY = "#d1d1d1"; // light gray
  const ORANGE = "#c9713a"; // warm orange-brown
  const GOLD = "#c9953e"; // golden amber
  const RED = "#d2462f"; // red-orange

  const colorMap: Record<number, string> = {
    0: CHARCOAL, // main silhouette
    1: TEAL_D, // wing
    2: GOLD, // belly
    3: GOLD, // belly
    4: TEAL_M, // head panel
    5: TEAL_D, // tail side
    6: GOLD, // chest
    7: CHARCOAL, // lower body
    8: TEAL_M, // mid body
    9: TEAL_D, // head side
    10: GOLD, // lower chest
    11: TEAL_D, // back
    12: TEAL_M, // mid body
    13: "#1a1a1a", // gap between feet (matches page background)
    14: RED, // tail
    15: TEAL_M, // neck
    16: GOLD, // belly
    17: ORANGE, // tail
    18: TEAL_M, // head top
    19: TEAL_D, // upper body
    20: GOLD, // feet
    21: RED, // beak
    22: TEAL_D, // head side
    23: GOLD, // chest
    24: RED, // feet
    25: RED, // beak tip
    26: GOLD, // feet
    27: RED, // feet
    28: GOLD, // key/eye
    29: TEAL_D, // body side
    30: TEAL_M, // head
    31: TEAL_D, // wing edge
    32: ORANGE, // tail
    33: RED, // feet
    34: GOLD, // belly edge
    35: GOLD, // belly edge
    36: ORANGE, // tail lower
    37: TEAL_D, // head edge
  };

  fetch("/bird.svg")
    .then((res) => res.text())
    .then((svgText) => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgText, "image/svg+xml");
      const svg = doc.querySelector("svg");
      const container = document.getElementById("bird-container");
      if (!svg || !container) return;

      svg.setAttribute("class", "bird-svg");
      svg.setAttribute("aria-hidden", "true");
      svg.removeAttribute("width");
      svg.removeAttribute("height");

      const paths = svg.querySelectorAll("path");
      if (paths.length > 0) paths[0].remove();

      const allPaths = svg.querySelectorAll("path");
      const totalPaths = allPaths.length;
      const drawDuration = 2;
      const drawStagger = 0.15;
      const drawEnd = (totalPaths - 1) * drawStagger + drawDuration;

      // Compute spatial bleed delay: center of bird bleeds first, edges last
      const center = { x: 600, y: 400 };
      const distances: number[] = [];
      allPaths.forEach((path) => {
        const t = path.getAttribute("transform") || "";
        const m = t.match(/translate\(([^,]+),([^)]+)\)/);
        const x = m ? parseFloat(m[1]) : 0;
        const y = m ? parseFloat(m[2]) : 0;
        distances.push(Math.sqrt((x - center.x) ** 2 + (y - center.y) ** 2));
      });
      const maxDist = Math.max(...distances);

      // Build fill paths first, then set up animations
      const fillPaths: SVGPathElement[] = [];

      allPaths.forEach((path, i) => {
        const length = path.getTotalLength();
        const fill = colorMap[i] || CHARCOAL;

        // Create a fill-only clone (inserted behind the stroke path)
        const fillPath = path.cloneNode(true) as SVGPathElement;
        fillPath.setAttribute("stroke", "none");
        fillPath.setAttribute("fill", fill);
        fillPath.style.clipPath = "inset(0 0 100% 0)";
        path.parentNode!.insertBefore(fillPath, path);
        fillPaths.push(fillPath);

        // Original path: stroke only
        path.setAttribute("stroke", "currentColor");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-width", "1.5");
        path.style.strokeDasharray = `${length}`;
        path.style.strokeDashoffset = `${length}`;

        const drawDelay = i * drawStagger;
        const bleedSpread = 3;
        const normalizedDist = distances[i] / maxDist;
        const fillDelay = drawEnd + normalizedDist * bleedSpread;
        const strokeFadeDelay = fillDelay + 0.5;

        path.style.animation = [
          `draw ${drawDuration}s ease forwards ${drawDelay}s`,
          `stroke-fade 1.5s ease forwards ${strokeFadeDelay}s`,
        ].join(", ");

        // Expand clip-path to reveal fill, creeping outward
        setTimeout(() => {
          fillPath.style.transition = "clip-path 2.5s ease-in";
          fillPath.style.clipPath = "inset(0 0 0% 0)";
        }, fillDelay * 1000);
      });

      // Gradually increase opacity as more paths draw in
      const minOpacity = 0.1;
      const maxOpacity = 0.75;
      allPaths.forEach((_, i) => {
        const t = i * drawStagger;
        const opacity = minOpacity + (maxOpacity - minOpacity) * ((i + 1) / totalPaths);
        setTimeout(() => {
          svg.style.transition = `opacity ${drawStagger * 2}s linear`;
          svg.style.opacity = `${opacity}`;
        }, t * 1000);
      });

      container.appendChild(svg);
    });
</script>
